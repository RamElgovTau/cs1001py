# Adifimport multiprocessingimport functoolsimport operatorimport os.pathimport inspectimport signalimport mathimport csvimport osimport xml.etree.ElementTree as ETfrom contextlib import contextmanagerfrom threading import Threadfrom importlib.machinery import SourceFileLoaderCSV_NAME = "grades.csv"TIME_LIMIT = 120  # time limit for single function run in secPRINT_PENALTY = 1  # how much penalty points for each function that uses printclass TimeoutException(Exception):    pass@contextmanagerdef time_limit(seconds):    # used to timeout on unix systems- see the optional in 'examine_for_errors'    def signal_handler(signum, frame):        raise TimeoutException("Timed out!")    signal.signal(signal.SIGALRM, signal_handler)    signal.alarm(seconds)    try:        yield    finally:        signal.alarm(0)def timeout(timeout):    def deco(func):        @functools.wraps(func)        def wrapper(*args, **kwargs):            res = [TimeoutException("TimeOut!")]            def new_func():                try:                    res[0] = func(*args, **kwargs)                except Exception as e:                    res[0] = e            t = Thread(target=new_func)            t.daemon = True            try:                t.start()                t.join(timeout)            except Exception as je:                print('error starting thread')                raise je            ret = res[0]            if isinstance(ret, BaseException):                raise ret            return ret        return wrapper    return decodef examine_for_errors(module_path, test_schema, output_dict):    total_grade = 0    total_errors = ""    student_id = get_id_from_path(module_path)    root = ET.parse(test_schema).getroot()    try:        hw_module = SourceFileLoader("test_name", module_path).load_module()  # TODO: change module name        set_tests(hw_module)    except Exception as e:        total_errors += "YYYE: " + str(e)        if student_id not in output_dict:            output_dict[student_id] = [0, ""]        output_dict[student_id] = list(map(operator.add, output_dict[student_id], [total_grade, total_errors]))        return    for function_obj in root:        try:            curr_function = getattr(hw_module, function_obj.tag)            if 'print(' in inspect.getsource(curr_function):                total_errors += function_obj.get("sign") + ": print, "                total_grade -= PRINT_PENALTY        except AttributeError:            total_errors += function_obj.get("sign") + ", "            continue        for test in function_obj:            grade = int(test.get("grade"))            sign = test.get("sign")            inputs = test.iterfind("input")            outputs = {output.get("id"): output for output in test.findall("output")}            success = True            for input_element in inputs:                input_id = input_element.get("id")                output_element = outputs[input_id]                try:                    input_valus = eval("[" + input_element.text + "]")                    output_values = eval("[" + output_element.text + "]")                    @timeout(TIME_LIMIT)                    def test_now(*input_valus):                        return curr_function(*input_valus)                    function_output = test_now(*input_valus)                    output_values = output_values[0]                except Exception as e:                    if "missing 1 required positional" in str(e):                        continue                    total_errors += "T" + sign + "E: '" + str(e) + "', "                    success = False                    break                if function_output != output_values:                    total_errors += "T" + sign + ", "                    success = False                    break            if success:                total_grade += grade    if student_id not in output_dict:        output_dict[student_id] = [0, ""]    output_dict[student_id] = list(map(operator.add, output_dict[student_id], [total_grade, total_errors]))def get_exercise_list(path):    exercise_list = os.listdir(path)    filter_fun = lambda file_name: (file_name.startswith('hw') and file_name.endswith(".py"))    exercise_list = list(map(lambda file_name: os.path.join(path, file_name), filter(filter_fun, exercise_list)))    return exercise_listdef grade_submissions(exercise_list, test_schema):    manager = multiprocessing.Manager()    graded_submissions_dict = manager.dict()    pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())    pool.starmap(examine_for_errors,                 ((exercise_path, test_schema, graded_submissions_dict) for exercise_path in exercise_list))    pool.starmap(find_conventions_errors, ((exercise_path, graded_submissions_dict) for exercise_path in exercise_list))    return dict(graded_submissions_dict)def find_conventions_errors(exercise_path, graded_submissions_dict):    # for future implementation    returndef write_results_to_csv(csv_path, graded_submissions):    with open(csv_path + CSV_NAME, 'w') as csvfile:        writer = csv.DictWriter(csvfile, fieldnames=["id", "grade", "errors"], delimiter=",")        for student_id in graded_submissions:            grade = graded_submissions[student_id][0]            errors = graded_submissions[student_id][1]            writer.writerow({"id": student_id, "grade": grade, "errors": errors})def get_id_from_path(path):    return os.path.basename(path)[4:-3]def set_tests(hw_module):    def test_coin(x):        c = 1000        count = 0        for _ in range(c):            count += 1 if hw_module.coin() else -1        return abs(count) <= c // 5    def test_roll_dice(d):        c = 1000        out = []        for _ in range(c):            out.append(hw_module.roll_dice(d))        for i in range(1, d + 1):            if not 1 / (d + 3) < out.count(i) / c < 1 / (d - 3):                return False        return True    def test_roulette(parity):        c = 1000        count = 0        for _ in range(c):            count += hw_module.roulette(1, parity)        return c * 0.9 < count < c * 1.1    def test_roulette_repeat(bet_size, n):        out = hw_module.roulette_repeat(bet_size, n)        return -n * bet_size / 6 < out < n * bet_size / 30    def test_shuffle_list(l: list):        n = len(l)        s = set()        for _ in range(10 * n ** 2):            s.add(tuple(l))            l = hw_module.shuffle_list(l)        return len(s) == math.factorial(n)    def test_avg_count_steps(d):        out = hw_module.avg_count_steps(d)        return abs(math.sqrt(out) - d) < 2    def test_count_steps_2dim(d):        c = 100        out = 0        for i in range(c):            out += hw_module.count_steps_2dim(d)        out /= c        return d ** 1.7 < out < d ** 2.3    d = {'test_coin': test_coin, 'test_roll_dice': test_roll_dice, 'test_roulette': test_roulette,         'test_roulette_repeat': test_roulette_repeat, 'test_shuffle_list': test_shuffle_list,         'test_avg_count_steps': test_avg_count_steps, 'test_count_steps_2dim': test_count_steps_2dim}    for k in d:        setattr(hw_module, k, d[k])def main():    file_location = input("Insert python file location (or folder for multiple files): ")    scheme_path = input("Insert scheme file location: ")    if os.path.isfile(file_location):        d = {}        examine_for_errors(file_location, scheme_path, d)        out = d[list(d.keys())[0]]        print("grade: ", out[0])        print("errors: ", out[1])    elif os.path.isdir(file_location):        # expected python names are: "hw#_123456789.py"        file_location += "\\"        submissions = get_exercise_list(file_location)        graded_submissions_dict = grade_submissions(submissions, scheme_path)        write_results_to_csv(file_location, graded_submissions_dict)    else:        print("Wrong input type")        input()if __name__ == '__main__':    main()